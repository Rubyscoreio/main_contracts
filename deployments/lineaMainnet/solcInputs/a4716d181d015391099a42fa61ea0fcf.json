{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/certificates/abstracts/AbstractPortal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {IAttestationRegistry} from \"../interfaces/IAttestationRegistry.sol\";\nimport {IModuleRegistry} from \"../interfaces/IModuleRegistry.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {IPortalRegistry} from \"../interfaces/IPortalRegistry.sol\";\nimport {IRouter} from \"../interfaces/IRouter.sol\";\nimport {IPortal} from \"../interfaces/IPortal.sol\";\nimport {AttestationPayload} from \"../interfaces/Structs.sol\";\n\n/**\n * @title Abstract Portal\n * @author Consensys\n * @notice This contract is an abstract contract with basic Portal logic\n *         to be inherited. We strongly encourage all Portals to implement\n *         this contract.\n */\nabstract contract AbstractPortal is IPortal {\n    IRouter public router;\n    address[] public modules;\n    IModuleRegistry public moduleRegistry;\n    IAttestationRegistry public attestationRegistry;\n    IPortalRegistry public portalRegistry;\n\n    /// @notice Error thrown when someone else than the portal's owner is trying to revoke\n    error OnlyPortalOwner();\n\n    /**\n     * @notice Contract constructor\n     * @param _modules list of modules to use for the portal (can be empty)\n     * @param _router Router's address\n     * @dev This sets the addresses for the IAttestationRegistry, IModuleRegistry and IPortalRegistry\n     */\n    constructor(address[] memory _modules, address _router) {\n        modules = _modules;\n        router = IRouter(_router);\n        attestationRegistry = IAttestationRegistry(router.getAttestationRegistry());\n        moduleRegistry = IModuleRegistry(router.getModuleRegistry());\n        portalRegistry = IPortalRegistry(router.getPortalRegistry());\n    }\n\n    /**\n     * @notice Optional method to withdraw funds from the Portal\n     * @param to the address to send the funds to\n     * @param amount the amount to withdraw\n     */\n    function withdraw(address payable to, uint256 amount) external virtual;\n\n    /**\n     * @notice Attest the schema with given attestationPayload and validationPayload\n     * @param attestationPayload the payload to attest\n     * @param validationPayloads the payloads to validate via the modules to issue the attestations\n     * @dev Runs all modules for the portal and registers the attestation using IAttestationRegistry\n     */\n    function attest(AttestationPayload memory attestationPayload, bytes[] memory validationPayloads) public payable {\n        moduleRegistry.runModules(modules, attestationPayload, validationPayloads, msg.value);\n\n        _onAttest(attestationPayload, getAttester(), msg.value);\n\n        attestationRegistry.attest(attestationPayload, getAttester());\n    }\n\n    /**\n     * @notice Bulk attest the schema with payloads to attest and validation payloads\n     * @param attestationsPayloads the payloads to attest\n     * @param validationPayloads the payloads to validate via the modules to issue the attestations\n     */\n    function bulkAttest(AttestationPayload[] memory attestationsPayloads, bytes[][] memory validationPayloads) public {\n        moduleRegistry.bulkRunModules(modules, attestationsPayloads, validationPayloads);\n\n        _onBulkAttest(attestationsPayloads, validationPayloads);\n\n        attestationRegistry.bulkAttest(attestationsPayloads, getAttester());\n    }\n\n    /**\n     * @notice Replaces the attestation for the given identifier and replaces it with a new attestation\n     * @param attestationId the ID of the attestation to replace\n     * @param attestationPayload the attestation payload to create the new attestation and register it\n     * @param validationPayloads the payloads to validate via the modules to issue the attestation\n     * @dev Runs all modules for the portal and registers the attestation using IAttestationRegistry\n     */\n    function replace(\n        bytes32 attestationId,\n        AttestationPayload memory attestationPayload,\n        bytes[] memory validationPayloads\n    ) public payable {\n        moduleRegistry.runModules(modules, attestationPayload, validationPayloads, msg.value);\n\n        _onReplace(attestationId, attestationPayload, getAttester(), msg.value);\n\n        attestationRegistry.replace(attestationId, attestationPayload, getAttester());\n    }\n\n    /**\n     * @notice Bulk replaces the attestation for the given identifiers and replaces them with new attestations\n     * @param attestationIds the list of IDs of the attestations to replace\n     * @param attestationsPayloads the list of attestation payloads to create the new attestations and register them\n     * @param validationPayloads the payloads to validate via the modules to issue the attestations\n     */\n    function bulkReplace(\n        bytes32[] memory attestationIds,\n        AttestationPayload[] memory attestationsPayloads,\n        bytes[][] memory validationPayloads\n    ) public {\n        moduleRegistry.bulkRunModules(modules, attestationsPayloads, validationPayloads);\n\n        _onBulkReplace(attestationIds, attestationsPayloads, validationPayloads);\n\n        attestationRegistry.bulkReplace(attestationIds, attestationsPayloads, getAttester());\n    }\n\n    /**\n     * @notice Revokes an attestation for the given identifier\n     * @param attestationId the ID of the attestation to revoke\n     * @dev By default, revocation is only possible by the portal owner\n     * We strongly encourage implementing such a rule in your Portal if you intend on overriding this method\n     */\n    function revoke(bytes32 attestationId) public {\n        _onRevoke(attestationId);\n\n        attestationRegistry.revoke(attestationId);\n    }\n\n    /**\n     * @notice Bulk revokes a list of attestations for the given identifiers\n     * @param attestationIds the IDs of the attestations to revoke\n     */\n    function bulkRevoke(bytes32[] memory attestationIds) public {\n        _onBulkRevoke(attestationIds);\n\n        attestationRegistry.bulkRevoke(attestationIds);\n    }\n\n    /**\n     * @notice Get all the modules addresses used by the Portal\n     * @return The list of modules addresses linked to the Portal\n     */\n    function getModules() external view returns (address[] memory) {\n        return modules;\n    }\n\n    /**\n     * @notice Verifies that a specific interface is implemented by the Portal, following ERC-165 specification\n     * @param interfaceID the interface identifier checked in this call\n     * @return The list of modules addresses linked to the Portal\n     */\n    function supportsInterface(bytes4 interfaceID) public pure virtual override returns (bool) {\n        return\n            interfaceID == type(AbstractPortal).interfaceId ||\n            interfaceID == type(IPortal).interfaceId ||\n            interfaceID == type(IERC165).interfaceId;\n    }\n\n    /**\n     * @notice Defines the address of the entity issuing attestations to the subject\n     * @dev We strongly encourage a reflection when overriding this rule: who should be set as the attester?\n     */\n    function getAttester() public view virtual returns (address) {\n        return msg.sender;\n    }\n\n    /**\n     * @notice Optional method run before a payload is attested\n     * @param attestationPayload the attestation payload supposed to be attested\n     * @param attester the address of the attester\n     * @param value the value sent with the attestation\n     */\n    function _onAttest(\n        AttestationPayload memory attestationPayload,\n        address attester,\n        uint256 value\n    ) internal virtual {}\n\n    /**\n     * @notice Optional method run when an attestation is replaced\n     * @param attestationId the ID of the attestation being replaced\n     * @param attestationPayload the attestation payload to create attestation and register it\n     * @param attester the address of the attester\n     * @param value the value sent with the attestation\n     */\n    function _onReplace(\n        bytes32 attestationId,\n        AttestationPayload memory attestationPayload,\n        address attester,\n        uint256 value\n    ) internal virtual {}\n\n    /**\n     * @notice Optional method run when attesting a batch of payloads\n     * @param attestationsPayloads the payloads to attest\n     * @param validationPayloads the payloads to validate in order to issue the attestations\n     */\n    function _onBulkAttest(\n        AttestationPayload[] memory attestationsPayloads,\n        bytes[][] memory validationPayloads\n    ) internal virtual {}\n\n    function _onBulkReplace(\n        bytes32[] memory attestationIds,\n        AttestationPayload[] memory attestationsPayloads,\n        bytes[][] memory validationPayloads\n    ) internal virtual {}\n\n    /**\n     * @notice Optional method run when an attestation is revoked or replaced\n     * @dev    IMPORTANT NOTE: By default, revocation is only possible by the portal owner\n     */\n    function _onRevoke(bytes32 /*attestationId*/) internal virtual {\n        if (msg.sender != portalRegistry.getPortalByAddress(address(this)).ownerAddress) revert OnlyPortalOwner();\n    }\n\n    /**\n     * @notice Optional method run when a batch of attestations are revoked or replaced\n     * @dev    IMPORTANT NOTE: By default, revocation is only possible by the portal owner\n     */\n    function _onBulkRevoke(bytes32[] memory /*attestationIds*/) internal virtual {\n        if (msg.sender != portalRegistry.getPortalByAddress(address(this)).ownerAddress) revert OnlyPortalOwner();\n    }\n}\n"
    },
    "contracts/certificates/interfaces/IAttestationRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {Attestation, AttestationPayload} from \"./Structs.sol\";\nimport {IRouter} from \"./IRouter.sol\";\n\ninterface IAttestationRegistry {\n    /// @notice Event emitted when an attestation is registered\n    event AttestationRegistered(bytes32 indexed attestationId);\n\n    function router() external view returns (IRouter);\n\n    function attestations(bytes32 attestationId) external view returns (Attestation memory);\n\n    function initialize() external;\n\n    function updateRouter(address _router) external;\n\n    function updateChainPrefix(uint256 _chainPrefix) external;\n\n    function onlyPortals(address portal) external view;\n\n    function attest(AttestationPayload calldata attestationPayload, address attester) external;\n\n    function bulkAttest(AttestationPayload[] calldata attestationsPayloads, address attester) external;\n\n    function massImport(AttestationPayload[] calldata attestationsPayloads, address portal) external;\n\n    function replace(bytes32 attestationId, AttestationPayload calldata attestationPayload, address attester) external;\n\n    function bulkReplace(\n        bytes32[] calldata attestationIds,\n        AttestationPayload[] calldata attestationPayloads,\n        address attester\n    ) external;\n\n    function revoke(bytes32 attestationId) external;\n\n    function bulkRevoke(bytes32[] memory attestationIds) external;\n\n    function isRegistered(bytes32 attestationId) external view returns (bool);\n\n    function isRevocable(address portalId) external view returns (bool);\n\n    function getAttestation(bytes32 attestationId) external view returns (Attestation memory);\n\n    function incrementVersionNumber() external returns (uint16);\n\n    function getVersionNumber() external view returns (uint16);\n\n    function getAttestationIdCounter() external view returns (uint32);\n\n    function getChainPrefix() external view returns (uint256);\n\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids) external view returns (uint256[] memory);\n}\n"
    },
    "contracts/certificates/interfaces/IModuleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {Module, AttestationPayload} from \"./Structs.sol\";\nimport {IRouter} from \"./IRouter.sol\";\n\ninterface IModuleRegistry {\n    function router() external view returns (IRouter);\n\n    function modules(address moduleAddress) external view returns (Module memory);\n\n    function moduleAddresses(uint256 index) external view returns (address);\n\n    function initialize() external;\n\n    function updateRouter(address _router) external;\n\n    function isContractAddress(address contractAddress) external view returns (bool);\n\n    function onlyIssuers(address issuer) external view;\n\n    function register(string memory name, string memory description, address moduleAddress) external;\n\n    function runModules(\n        address[] memory modulesAddresses,\n        AttestationPayload memory attestationPayload,\n        bytes[] memory validationPayloads,\n        uint256 value\n    ) external;\n\n    function bulkRunModules(\n        address[] memory modulesAddresses,\n        AttestationPayload[] memory attestationsPayloads,\n        bytes[][] memory validationPayloads\n    ) external;\n\n    function getModulesNumber() external view returns (uint256);\n\n    function isRegistered(address moduleAddress) external view returns (bool);\n}\n"
    },
    "contracts/certificates/interfaces/IPortal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\n/**\n * @title IPortal\n * @author Consensys\n * @notice This contract is the interface to be implemented by any Portal.\n *         NOTE: A portal must implement this interface to registered on\n *         the PortalRegistry contract.\n */\ninterface IPortal is IERC165 {\n    /**\n     * @notice Get all the modules addresses used by the Portal\n     * @return The list of modules addresses linked to the Portal\n     */\n    function getModules() external view returns (address[] memory);\n\n    /**\n     * @notice Defines the address of the entity issuing attestations to the subject\n     * @dev We strongly encourage a reflection when implementing this method\n     */\n    function getAttester() external view returns (address);\n}\n"
    },
    "contracts/certificates/interfaces/IPortalRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {Portal} from \"./Structs.sol\";\nimport {IRouter} from \"./IRouter.sol\";\n\ninterface IPortalRegistry {\n    function router() external view returns (IRouter);\n\n    function portals(address id) external view returns (Portal memory);\n\n    function issuers(address issuerAddress) external view returns (bool);\n\n    function portalAddresses(uint256 index) external view returns (address);\n\n    function initialize() external;\n\n    function updateRouter(address _router) external;\n\n    function setIssuer(address issuer) external;\n\n    function removeIssuer(address issuer) external;\n\n    function isIssuer(address issuer) external view returns (bool);\n\n    function register(\n        address id,\n        string memory name,\n        string memory description,\n        bool isRevocable,\n        string memory ownerName\n    ) external;\n\n    function revoke(address id) external;\n\n    function deployDefaultPortal(\n        address[] calldata modules,\n        string memory name,\n        string memory description,\n        bool isRevocable,\n        string memory ownerName\n    ) external;\n\n    function getPortalByAddress(address id) external view returns (Portal memory);\n\n    function isRegistered(address id) external view returns (bool);\n\n    function getPortalsCount() external view returns (uint256);\n}\n"
    },
    "contracts/certificates/interfaces/IRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\n/**\n * @title Router\n * @author Consensys\n * @notice This contract aims to provides a single entrypoint for the Verax registries\n */\ninterface IRouter {\n    /**\n     * @notice Gives the address for the AttestationRegistry contract\n     * @return The current address of the AttestationRegistry contract\n     */\n    function getAttestationRegistry() external view returns (address);\n\n    /**\n     * @notice Gives the address for the ModuleRegistry contract\n     * @return The current address of the ModuleRegistry contract\n     */\n    function getModuleRegistry() external view returns (address);\n\n    /**\n     * @notice Gives the address for the PortalRegistry contract\n     * @return The current address of the PortalRegistry contract\n     */\n    function getPortalRegistry() external view returns (address);\n\n    /**\n     * @notice Gives the address for the SchemaRegistry contract\n     * @return The current address of the SchemaRegistry contract\n     */\n    function getSchemaRegistry() external view returns (address);\n}\n"
    },
    "contracts/certificates/interfaces/IRubyscore_Certificates.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.19;\n\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\n/**\n * @title IRubyscore_Certificates\n * @dev IRubyscore_Certificates is an interface for Rubyscore_Certificates contract\n */\ninterface IRubyscore_Certificates is IERC1155 {\n    /**\n     * @notice Emitted when the base URI for token metadata is updated.\n     * @param newBaseURI The new base URI that will be used to construct token metadata URIs.\n     * @dev This event is triggered when the contract operator updates the base URI\n     * for retrieving metadata associated with tokens. The 'newBaseURI' parameter represents\n     * the updated base URI.\n     */\n    event BaseURISet(string indexed newBaseURI);\n\n    /**\n     * @notice Emitted when NFTs are minted for a user.\n     * @param userAddress The address of the user receiving the NFTs.\n     * @param nftId NFT IDs that were minted.\n     * @dev This event is emitted when new NFTs are created and assigned to a user.\n     * @dev It includes the user's address, and the ID of the minted NFT for transparency.\n     */\n    event Minted(address indexed userAddress, uint256 nftId);\n\n    /**\n     * @notice Emitted when NFTs are minted for a user.\n     * @param userAddress The address of the user receiving the NFTs.\n     * @param nftIds NFT IDs that were minted.\n     * @dev This event is emitted when new NFTs are created and assigned to a user.\n     * @dev It includes the user's address and the IDs of the minted NFTs for transparency.\n     */\n    event BatchMinted(address indexed userAddress, uint256[] nftIds);\n\n    /**\n     * @notice Emitted when the URI for a specific token is updated.\n     * @param tokenId The ID of the token for which the URI is updated.\n     * @param newTokenURI The new URI assigned to the token.\n     * @dev This event is emitted when the URI for a token is modified, providing transparency\n     * when metadata URIs are changed for specific tokens.\n     */\n    event TokenURISet(uint256 indexed tokenId, string indexed newTokenURI);\n\n    /**\n     * @notice Get token name.\n     * @return Token name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @notice Get token symbol.\n     * @return Token symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @notice Get the URI of a token.\n     * @param tokenId The ID of the token.\n     * @return The URI of the token.\n     */\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    /**\n     * @notice Get the token URI for a given tokenId.\n     * @param tokenId The ID of the token.\n     * @return The URI of the token.\n     * @dev Diblicate for uri() method\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n\n    /**\n     * @notice Set the URI for a token.\n     * @param tokenId The ID of the token.\n     * @param newTokenURI The new URI to set for the token.\n     * @dev Requires the MINTER_ROLE.\n     */\n    function setTokenURI(uint256 tokenId, string memory newTokenURI) external;\n\n    /**\n     * @notice Set the URIs for multiple tokens in a batch.\n     * @param tokenIds An array of token IDs to set URIs for.\n     * @param newTokenURIs An array of new URIs to set for the tokens.\n     * @dev Requires the MINTER_ROLE.\n     * @dev Requires that the tokenIds and newTokenURIs arrays have the same length.\n     */\n    function setBatchTokenURI(uint256[] calldata tokenIds, string[] calldata newTokenURIs) external;\n\n    /**\n     * @notice Set the base URI for all tokens.\n     * @param newBaseURI The new base URI to set.\n     * @dev Requires the OPERATOR_ROLE.\n     */\n    function setBaseURI(string memory newBaseURI) external;\n\n    /**\n     * @notice Safely mints NFT for a user.\n     * @param to The NFT recipient.\n     * @param id The NFT id.\n     */\n    function safeMint(address to, uint256 id) external payable;\n\n    /**\n     * @notice Check if a given interface is supported by this contract.\n     * @param interfaceId The interface identifier to check for support.\n     * @return Whether the contract supports the specified interface.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/certificates/interfaces/Structs.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nstruct AttestationPayload {\n    bytes32 schemaId; // The identifier of the schema this attestation adheres to.\n    uint64 expirationDate; // The expiration date of the attestation.\n    bytes subject; // The ID of the attestee, EVM address, DID, URL etc.\n    bytes attestationData; // The attestation data.\n}\n\nstruct Attestation {\n    bytes32 attestationId; // The unique identifier of the attestation.\n    bytes32 schemaId; // The identifier of the schema this attestation adheres to.\n    bytes32 replacedBy; // Whether the attestation was replaced by a new one.\n    address attester; // The address issuing the attestation to the subject.\n    address portal; // The id of the portal that created the attestation.\n    uint64 attestedDate; // The date the attestation is issued.\n    uint64 expirationDate; // The expiration date of the attestation.\n    uint64 revocationDate; // The date when the attestation was revoked.\n    uint16 version; // Version of the registry when the attestation was created.\n    bool revoked; // Whether the attestation is revoked or not.\n    bytes subject; // The ID of the attestee, EVM address, DID, URL etc.\n    bytes attestationData; // The attestation data.\n}\n\nstruct Schema {\n    string name; // The name of the schema.\n    string description; // A description of the schema.\n    string context; // The context of the schema.\n    string schema; // The schema definition.\n}\n\nstruct Portal {\n    address id; // The unique identifier of the portal.\n    address ownerAddress; // The address of the owner of this portal.\n    address[] modules; // Addresses of modules implemented by the portal.\n    bool isRevocable; // Whether attestations issued can be revoked.\n    string name; // The name of the portal.\n    string description; // A description of the portal.\n    string ownerName; // The name of the owner of this portal.\n}\n\nstruct Module {\n    address moduleAddress; // The address of the module.\n    string name; // The name of the module.\n    string description; // A description of the module.\n}\n"
    },
    "contracts/certificates/RubyScoreVeraxPortal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {AbstractPortal} from \"./abstracts/AbstractPortal.sol\";\nimport {AttestationPayload} from \"./interfaces/Structs.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IRubyscore_Certificates} from \"./interfaces/IRubyscore_Certificates.sol\";\n\n/**\n * @title RubyScoreVeraxPortal\n * @dev RubyScoreVeraxPortal is a smart contract that handles the attestation process for RubyScore certificates.\n * It manages fees, signatures based on specific schemas.\n */\ncontract RubyScoreVeraxPortal is AbstractPortal, Ownable, Pausable {\n    // State variables\n    bool public bulkStatus = false;\n    bool public feeStatus = true;\n\n    // Storage\n    mapping(bytes32 => bool) public certificates; // schemaId => certificateStatus\n    mapping(bytes32 => uint256) public attestationFees; // schemaId => attestationFee\n\n    // Errors\n    error InvalidCertificateId();\n    error ArrayLengthMismatch();\n    error InvalidAttestationFee();\n    error ZeroAddressCheck();\n    error WithdrawFail();\n\n    // Events\n    event FeesSet(bytes32[] schemaIds, uint256[] attestationFees);\n\n    /**\n     * @dev Contract constructor.\n     * @param modules List of modules to use for the portal.\n     * @param router The Router's address.\n     */\n    constructor(address[] memory modules, address router) AbstractPortal(modules, router) {\n        if (router == address(0)) revert ZeroAddressCheck();\n        _transferOwnership(msg.sender);\n    }\n\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @dev Check if the provided value meets the attestation fee requirement.\n     * @param schemaId The schemaId for which to check the fee.\n     * @param _value The value sent for the attestation.\n     */\n    function checkFee(bytes32 schemaId, uint256 _value) public view {\n        if (_value < attestationFees[schemaId]) revert InvalidAttestationFee();\n    }\n\n    /**\n     * @dev Set the fee, signature, and issuance statuses.\n     * @param fee Fee status.\n     */\n    function setCheckStatuses(bool fee, bool bulk) external onlyOwner {\n        feeStatus = fee;\n        bulkStatus = bulk;\n    }\n\n    /**\n     * @dev Add a new module to the list of modules.\n     * @param module The address of the new module.\n     */\n    function addModule(address module) external onlyOwner {\n        modules.push(module);\n    }\n\n    /**\n     * @dev Remove all modules from the list of modules.\n     */\n    function removeModules() external onlyOwner whenPaused {\n        delete modules;\n    }\n\n    /**\n     * @dev Set the fees for specific schemaIds.\n     * @param schemaIds The schemaIds to set the fee for.\n     * @param _attestationFees The fees required to attest.\n     */\n    function setFees(bytes32[] memory schemaIds, uint256[] memory _attestationFees) public onlyOwner {\n        if (schemaIds.length != _attestationFees.length) revert ArrayLengthMismatch();\n        for (uint256 i = 0; i < schemaIds.length; i++) {\n            attestationFees[schemaIds[i]] = _attestationFees[i];\n        }\n        emit FeesSet(schemaIds, _attestationFees);\n    }\n\n    /**\n     * @dev Set up certificate mappings for schemaIds.\n     * @param schemaIds The schemaIds for which to set up certificates.\n     * @param certificateStatuses The corresponding certificate statuses.\n     */\n    function setUpCertificates(bytes32[] calldata schemaIds, bool[] calldata certificateStatuses) public onlyOwner {\n        if (schemaIds.length != certificateStatuses.length) revert ArrayLengthMismatch();\n        for (uint256 i = 0; i < schemaIds.length; i++) {\n            certificates[schemaIds[i]] = certificateStatuses[i];\n        }\n    }\n\n    /**\n     * @dev Attest a score with a given attestation payload and validation payloads.\n     * @param attestationPayload The payload of the attestation.\n     * @param validationPayload The validation payload required for the module.\n     */\n    function attestRubyscore(\n        AttestationPayload memory attestationPayload,\n        bytes[] memory validationPayload\n    ) external payable {\n        super.attest(attestationPayload, validationPayload);\n    }\n\n    /**\n     * @dev Withdraw ETH from the contract.\n     * @param to The address to which the ETH will be withdrawn.\n     * @param amount The amount of ETH to withdraw.\n     */\n    function withdraw(address payable to, uint256 amount) external override onlyOwner {\n        (bool status, ) = to.call{value: amount}(\"\");\n        if (!status) revert WithdrawFail();\n    }\n\n    /**\n     * @notice Optional method run before a payload is attested\n     * @param attestationPayload the attestation payload supposed to be attested\n     * @param attester the address of the attester\n     * @param value the value sent with the attestation\n     */\n    function _onAttest(\n        AttestationPayload memory attestationPayload,\n        address attester,\n        uint256 value\n    ) internal override whenNotPaused {\n        if (!certificates[attestationPayload.schemaId]) revert InvalidCertificateId();\n        if (feeStatus) checkFee(attestationPayload.schemaId, value);\n        super._onAttest(attestationPayload, attester, value);\n    }\n\n    /**\n     * @notice Optional method run when attesting a batch of payloads\n     */\n    function _onBulkAttest(\n        AttestationPayload[] memory attestationsPayloads,\n        bytes[][] memory validationPayloads\n    ) internal override whenNotPaused {\n        if (!bulkStatus) revert(\"Only single attest\");\n        for (uint256 i = 0; i < attestationsPayloads.length; i++) {\n            if (!certificates[attestationsPayloads[i].schemaId]) revert InvalidCertificateId();\n        }\n        super._onBulkAttest(attestationsPayloads, validationPayloads);\n    }\n\n    /**\n     * @notice Optional method run when an attestation is replaced\n     * @param attestationId the ID of the attestation being replaced\n     * @param attestationPayload the attestation payload to create attestation and register it\n     * @param attester the address of the attester\n     * @param value the value sent with the attestation\n     */\n    function _onReplace(\n        bytes32 attestationId,\n        AttestationPayload memory attestationPayload,\n        address attester,\n        uint256 value\n    ) internal override whenNotPaused {\n        if (!certificates[attestationPayload.schemaId]) revert InvalidCertificateId();\n        if (feeStatus) checkFee(attestationPayload.schemaId, value);\n        super._onReplace(attestationId, attestationPayload, attester, value);\n    }\n\n    function _onBulkReplace(\n        bytes32[] memory attestationIds,\n        AttestationPayload[] memory attestationsPayloads,\n        bytes[][] memory validationPayloads\n    ) internal override whenNotPaused {\n        if (!bulkStatus) revert(\"Only single replace\");\n        for (uint256 i = 0; i < attestationsPayloads.length; i++) {\n            if (!certificates[attestationsPayloads[i].schemaId]) revert InvalidCertificateId();\n        }\n        super._onBulkReplace(attestationIds, attestationsPayloads, validationPayloads);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}